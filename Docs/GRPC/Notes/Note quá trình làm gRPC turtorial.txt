1. create new project
	nest new apigateway 
2. cd apigateway 
	nest generate app auth 
	- APIGateway will receive all of the http traffic in app and gonna to proxy those call onto the auth microservice using gRPC
3. generate users resources 
	- nest g resource users 
		+ auth-microservices(non-http)- yes crud generate
4. install some package 	
	npm install --save @nestjs/microservices @grpc/grpc-js @grpc/proto-loader ts-proto
5. create new Proto folder in root project 
6. define auth.proto in folder proto 
7. Use TS proto package to generate typescript code from proto def in .proto file 
	- Use Protocol Buffer (mô phỏng quá trình protocol buffer generate from .proto file )
	- Use protoc lib install in window to demo 
	- After file ts generated from .proto file 
	- generate lib common (nest g lib common) 
	- move file ts generated to lib common 
	- refactor auth nestcli.json  
		+ want to copy proto folder into dist (folder sau khi built)
		+ change sourceroot of auth in nest-cli.json (to root path ./) before apps/auth/src
		+ change entry file src 
		+ change compiler options (add asset is .proto file) 
			* watchAssets: true (if any change in protofile , will copy over )
	- refactor apigateway nestcli.json (tuong tu) 
	- refactor root of project in nestcli.json
8. Use proto file in our running app (when start up our microservices)
	- Apps/auth/src main.ts chi dinh to use grpc 
9. Config user controller to use gRPC 	
	- implement UserServiceController defined in generated file 
	- use create and updatedto defined in generated file 
	- decorate controller with decorator @UserServiceControllerMethod() (function export from gennerated file)
	- remove @MessagePattern decorator for each function of controller 
	- Ts-Proto will decorate with proper metadata 
	- change name to the name defined in generated file 
	- delete decorator payload() (TS proto will provide param ) 
	- refactor UserService to implement crud functionality 	
		+ implement OnModuleInit (to use bootstrap hook OnModuleInit() create random 100 user 
		+ done demo then have to read again queryUsers method 
10. Implement API gateway 
	- implement gRPC method in Controller --> expose these methods so that call them from a restAPI 
	- do it in API gateway 
	- API gateway expose an HTTP server where we can call our auth microservice using grpc 
	- generate users resource 
	nest g resource users 
		+ generate in apigateway 
		+ use REST API transport layer 
		+ generate CRUD 
	- move Users folder into apps/apigateway/src
	- delete app service and controller in apigateway 
	- delete dto and entity folder in apigateway/src/users 
	- Use entity and dto from generated file 
	- crud method in user controller will proxy auth to our auth microservice 
	- in user service implement proxy 
		+ set up connection from User.module to auth microservice 
			*Use ClientModule.register (name: 
		inject auth module and use it 
		+ implements onModuleInit 
		+ declare UserServiceClient from generated file 
		+ Inject authservice 
		+ use OnModuleInit hook to declare user service 
		+ create method return an observable with user inside (so what is observable) 
		+ in nestjs when return an observable and then we return it from the calling controller nestjs automatically subscribe to the observable 
		and return the value within so return this user from this rpc call 
		+ after demo read again emailUsers method 
			* reach out the auth microservice get each chunk of users and let's say we want to send an email out to each of these users 
				- retrieve these users in chunks (not want to return all users in once and overload our server) 
				- instead want to receive little chunks of users each page and then email the users in each page that get back 
			from the auth microservice using a stream 
	- in user controller 
		add new endpoint to sendEmail 
		còn bị lỗi apigateway 
11. Test with api 
	- get all user 
		+ get autogenerated array of user send back from our auth microservice using grpc from the gateway to auth 
	- create user 
	- findone 
	- delete 
	- update 
	- email user 
		+ logging four time for each chunk 
		+ each time is a different set of users in this massive list of users 
		+ avoid overload 






















































	
